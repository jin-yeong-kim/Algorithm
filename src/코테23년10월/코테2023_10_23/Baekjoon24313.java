package 코테23년10월.코테2023_10_23;

/*
https://www.acmicpc.net/problem/24313

빅오(O) 표기법은 알고리즘의 소요 시간을 나타내는 방법 중 하나로, 어떤 함수의 성장 속도를 나타냅니다. 이해할 수 있도록 아래에서 예시와 함께 설명하겠습니다.

먼저, O(g(n))라는 표기법은 함수 f(n)이 다른 함수 g(n)과 비교되는 방법입니다. 이때, n은 입력 크기를 나타내며, 일반적으로 어떤 알고리즘이 입력 크기 n에 따라 얼마나 빨리 실행되는지를 나타냅니다.

그리고 O(n)이라는 표기법은 함수 g(n) = n의 성장 속도를 나타냅니다. 이 함수는 n이 증가함에 따라 선형으로 증가합니다.

이제 O(n) 표기법의 정의를 살펴봅시다. O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다.

여기서 n0는 어떤 입력 크기를 기준으로 할 것인지를 나타내며, c는 상수입니다. O(n) 정의를 만족하려면 모든 n이 n0보다 크거나 같을 때, 함수 f(n)은 c배를 넘지 않는다는 뜻입니다.

예시 1:
입력으로 주어진 함수 f(n) = 7n + 7를 O(n)로 판단하려면, 양의 정수 c와 n0가 필요합니다. 예제에서 주어진 c는 8이고 n0는 1입니다. 그런데 f(1)은 14이고, c × g(1)은 8입니다. 따라서 f(1)이 c × g(1)보다 크기 때문에 O(n) 정의를 만족하지 않습니다. 따라서 출력은 0입니다.

예시 2:
입력으로 주어진 함수 f(n) = 7n + 7를 O(n)로 판단하려면, 양의 정수 c와 n0가 필요합니다. 예제에서 주어진 c는 8이고 n0는 10입니다. 모든 n ≥ 10에 대하여 7n + 7 ≤ 8n가 성립합니다. 따라서 모든 조건을 만족하므로 f(n)은 O(n) 정의를 만족하고, 출력은 1입니다.

요약하면, O(n) 표기법은 어떤 함수의 성장 속도를 빠르게 비교하고, 어떤 입력 크기에서 얼마나 빠르게 실행되는지를 이해하는데 도움을 주는 방법입니다. 이것은 알고리즘의 효율성을 판단하고 비교하는데 사용됩니다.*/

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;


public class Baekjoon24313 {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int[] fn = Arrays.stream(br.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
        int c = Integer.parseInt(br.readLine());
        int n0 = Integer.parseInt(br.readLine());
        if (((fn[0] * n0) + fn[1]) <= c * n0 && fn[0] <= c) { // fn[0] <= c 는 실질적으로 fn[0] * c를 하면 대략적인 f(n)의 값이 나오기 때문에 fn[0]이 c보다 크다면 빅오 표기법을 틀릴 수 밖에 없다.
            System.out.println(1);
        } else {
            System.out.println(0);
        }
    }
}
/*빅오(O) 표기법은 알고리즘의 성능을 나타내는 방법 중 하나로, 어떤 함수의 성장 속도를 나타냅니다.

빅오(O) 표기법은 함수 f(n)에 대한 성장 속도를 다른 함수 g(n)와 비교하는 방법입니다. 여기서 n은 입력 크기를 나타내며, 일반적으로 어떤 알고리즘이 입력 크기 n에 따라 얼마나 빨리 실행되는지를 나타냅니다.

이제 빅오(O) 표기법의 정의를 살펴보겠습니다.

O(g(n))은 "f(n)이 g(n)과 같거나 더 빠르게 성장한다"라는 아이디어를 나타냅니다. 다시 말하면, f(n)의 성장 속도가 g(n)의 성장 속도를 넘지 않는다는 뜻입니다.

여기서 중요한 것은 "모든 n ≥ n0에 대하여"라는 부분입니다. 이는 충분히 큰 입력 크기 n에 대해서만 고려한다는 것을 의미합니다. 즉, 입력 크기 n이 어느 정도 커져야 두 함수를 비교할 때의 규칙이 적용된다는 것입니다.

그리고 "f(n) ≤ c × g(n)" 부분은 두 함수 f(n)와 g(n)를 비교하는 부분입니다. 이것은 양의 상수 c를 곱해서 f(n)이 g(n)보다 작거나 같다는 것을 의미합니다. 즉, f(n)이 항상 g(n)보다 빨리 성장하지 않습니다.

따라서 빅오(O) 표기법은 어떤 함수의 성장 속도를 더 쉽게 이해하고 비교할 수 있도록 도와주는 도구입니다. 이것은 알고리즘의 효율성을 평가하고, 다양한 알고리즘을 비교하는 데 사용됩니다.*/

/*이 코드는 주어진 함수 f(n), 양의 정수 c, 양의 정수 n0가 O(n) 정의를 만족하는지 확인하는 Java 프로그램입니다. 이 프로그램을 초등학생도 이해할 수 있도록 설명하겠습니다.

먼저, 코드는 입력을 받기 위해 BufferedReader를 사용합니다. BufferedReader는 콘솔에서 입력을 읽어올 때 도움이 됩니다.

입력은 세 줄로 주어집니다. 첫 번째 줄에는 함수 f(n)을 나타내는 정수 a1과 a0가 주어집니다. a1은 n의 계수이고, a0는 상수 항입니다. 두 번째 줄에는 양의 정수 c가 주어지며, 세 번째 줄에는 양의 정수 n0가 주어집니다.

이어서 코드는 주어진 입력을 배열로 저장합니다. 예를 들어, 입력 "7 7"을 받으면 "7 7"을 공백을 기준으로 분리하여 [7, 7]으로 저장합니다. 양의 정수 c와 n0도 따로 변수로 저장합니다.

다음으로 코드는 O(n) 정의를 확인합니다. 이를 위해 주어진 함수 f(n)을 n0와 c를 사용하여 평가합니다. 이때, n0는 입력 크기를 나타내며, c는 양의 상수입니다.

만약 (a1 * n0 + a0)이 c * n0보다 작거나 같고, a1이 c보다 작거나 같다면, O(n) 정의를 만족한다고 판단하고 1을 출력합니다. 그렇지 않다면, O(n) 정의를 만족하지 않으므로 0을 출력합니다.

간단히 말하면, 이 프로그램은 주어진 함수 f(n), 양의 정수 c, 양의 정수 n0가 O(n) 정의를 만족하는지 확인하는데 사용됩니다. O(n) 정의를 만족하면 1을 출력하고, 그렇지 않으면 0을 출력합니다.*/